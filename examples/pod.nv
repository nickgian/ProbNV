(* A diamond network with bounded link failures *)

(* Declaring the nodes of the network in the form (#nodes, {nodeId:nodeName} ) *)
(* you can also just do 'let nodes = 4'*)
let nodes = (4, {0n:"A"; 1n:"B"; 2n:"C"; 3n:"D";})

(* Declaring the edges of the network. Use '-' for directed edges and '=' for bidirectional edges*)
let edges = {
    3-2;
    3-1;
    1-0;
    2-0;
}

symbolic f1 : tedge (*indicates the first failed link - uniform distribution assumed*)
symbolic f2 : tedge (*indicates the second failed link*)

(* The destination is node 3 announcing a route with zero cost.*)
let init u = 
  if u = 3n then Some 0 else None

let costIncr x =
  match x with
  | None -> None
  | Some y -> Some (y+1)

(* we need the type annotation for the mode here *)
let trans e (x :[M](option[int])) = 
  (* if the link e is either of the failed edges then drop the route *)
  if (f1 = f2) || (f2 = e) then None else costIncr x 


let merge u x y =
 match (x,y) with
 | (None, None) -> None
 | (_, None) -> x
 | (None, _) -> y
 | (Some a, Some b) -> if a < b then Some a else Some b

(* compute the routes of the given model *)
let rib = solution(init, trans, merge)

let reachable u =
  match rib[u] with | None -> false | _ -> true

(* What is the probability node 3 has a route, given that one or two links fail *)
assert(reachable 0n | f1 = f2 || f1 <e f2)