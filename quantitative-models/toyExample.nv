(* A diamond network with bounded link failures *)

type bgpType = {aslen: int; comms:set[int]; bgpNextHop: option[tedge];}
type route = option[bgpType]

let nodes = (4, {0n:"A"; 1n:"B"; 2n:"C"; 3n:"D";})

let edges = {
    3=2;
    3=1;
    1=0;
    2=0;
}

let init d u =
  match u with
  | 0n -> if (d = 0) then Some ({aslen = 0; comms = {}; bgpNextHop = None;}) else None
  | 3n -> if (d = 3n) then Some ({aslen = 0; comms = {}; bgpNextHop = None;}) else None
  | _ -> None

let trans e x = 
  match x with
  | None -> None
  | Some x ->    
    Some ({x with aslen = x.aslen+1; bgpNextHop = match e with | a~b -> toEdge b a;})

let merge u x y =
  match (x,y) with
  | (None, _) -> x
  | (_, None) -> y
  | (Some x, Some y) -> if x.aslen < y.aslen then Some x else Some y


(* Assuming every link fails with P(~A) = 0.1*)
(* Computed via the formula: (n choose k) * P(~A)^k * P(A)^(n-k) for k = # failures.
Let's assume we want to focus on at most 2 link failures *)
symbolic failures : int2 = | [0u2,0u2] -> 0.430467p | [1u2,1u2] -> 0.38263p | [2u2,2u2] -> 0.14880348p | [3u2,3u2] -> 0.0p

symbolic f0 : tedge (*indicates the first failed link - uniform distribution assumed*)
symbolic f1 : tedge (*indicates the second failed link*) 

let transLinkFaults e (x : [M]attribute) =
  if (failures >u2 0u2) && ((f0 = e) || (f1 = e)) then
      None
  else trans e x

let initLinkFaults d u = init d u 


(* Control plane solutions for destination 0 and 3 *)
let rib0 = solution(initLinkFaults 0, transLinkFaults, mergeLinkFaults)
let rib3 = solution(initLinkFaults 3, transLinkFaults, mergeLinkFaults)

(* Per TC model *)
type flow = {srcIp: int; dstIp: int; size: int;} (*flowSize should be float probably *)

(* Tc1: src 0 to dst 3*)
let initTc1 u = 
  if (u = 0n) then
    Some {srcIp = 0; dstIp = 3; size = 10;}
  else None

let fwdOutTc1 e flow =
  if (failures >u2 0u2) && ((f0 = e) || (f1 = e)) then
      None
  else
    (let u~v = e in
     if (rib[u].nextHop = Some (toEdge v u)) then
        Some flow
     else None
    )

(* Normally used for ACLs on the receiving switch *)
let fwdInTc1 e flow = flow

let hinitV u = ()
let hinitE e = 0

let logV u flow history = ()
let logE e flow history = flow.size + history

(* Compute the histories over nodes and edges *)
let (hVTc1, hETc2) = forward(initTc1, fwdOutTc1, fwdInTc1, hinitV, hinitE, logV, logE)

